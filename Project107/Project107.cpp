//Виртуальный деструктор класса C++. Что это такое. Наследование. Полиморфизм. Для начинающих #105 - Видео №122.

#include<iostream>
#include<string>
using namespace std;

class A
{
public:
	A()
	{
		cout << "Выделенна динамическая память, объкта А" << endl;
	}
	virtual ~A()
	{
		cout << "освобожденна динамическая память, объкта А" << endl;
	}
};

class B: public A
{
public:
	B()
	{
		cout << "Выделенна динамическая память, объкта B" << endl;
	}
	~B() override
	{
		cout << "освобожденна динамическая память, объкта B" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "ru");

	A *bptr = new B;
	delete bptr;

	return 0;
}
/*Очень эфективный способ подчистки памяти. Если ммыслкой идёи с одного конструктора на другой, не указав virtual,
у нас пойдёт утечкав памяти. Тоесть, в данной строке - A *bptr = new B; мы обращаемся к объекту B через указатель,
чистим память delete bptr;, но из за того что не указали virtual в классе, чиста только ттам и будет, а в лассе 
В произойдёт утечка.
Также для нас перестраховка, чтоб мы не забыли почистить память класса В, пишем override, он проконтролирует процесс,
и если он увидит что нет virtual, то не пропустит и выдаст ошибку.*/