//–екурси€. ‘акториал числа c++ рекурсивно. –екурси€ факториал. –екурсивный алгоритм факториал. #44

#include<iostream>
using namespace std;

/*
* ! - ƒанный знак, по формуле обозначает факториал, где N любое число.
ƒл€ примера, как вычисл€етьс€ факториал числа 3? —начала прописываем 3!=3*(3-1)!, но чтобы нам умножить 3*(3-1)!
надо вычеслить и само выражение факториала (3-1)!, а это значит, дальше по условию пишем 2!=2*(2-1)!, потомучто
по преведущему условию 3-1=2, и теперь 2 нужно найти его факториал и спускаемс€ ниже 1!=1, а факториал 1 всегда будет
1 и тоже самое факториал 0 всегда будит 0. 
» на примере стека, мы в самый низ поместили условие которое первое начали выполн€ть, это 3!=3*(3-1)!, затем 2!=2*(2-1)!
и затем это 1!=1. » теперь идЄм обратно, то что посложили последним, с него и начинаем. ¬озвращаем 1, и теперь 
умножаем 1 на 2 по условию 2!=2*(2-1)!, получили 2, возвращаем 2 и умножаем на 3 по условию 3!=3*(3-1)! и получаем
факториал числа 3 = 6. “аким образом, функцию которую положили в стек первую, к ней дошли в само конце.
    N! = N * (N-1)!
	3!=3*(3-1)!
	2!=2*(2-1)!
	1!=1
	
*/

/*ѕример уже закодированный, вычислени€ факториала 5. ≈диственное, добавили, выход из цикла чтоб небыл бесконечный.*/
int Fact(int N)// ќбозначение Fact и есть - !.
{
	if (N == 0)// ќдин выход, еси факторил станет 0
		return 0;
	if (N == 1)//¬торой выход , факторила 1 = 1.
		return 1;
	return N * Fact(N - 1);
	/*Ќесовсем тольок пон€л, зачем выход с 0 и с 1 делать, когда достаточно 1. Ќо проверил, если оставить только
	0, то по данной формуле тольк 0 всегда и будет, а если оставить только 1 то всЄ получаетьс€ и работает.
	Ќаверное это закономерность формулы.*/
}

void main()
{
	setlocale(LC_ALL, "Rus");

	cout << Fact(5) << endl;
}